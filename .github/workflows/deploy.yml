name: Deploy Django App

on:
  push:
    branches:
      - main

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: 1. Checkout do Código
        uses: actions/checkout@v3

      - name: 2. Login no Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: 3. Construir e Enviar Imagem Docker
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/digicoin_teste:latest

      - name: 4. Conectar no Servidor e Fazer Deploy
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            # Garante que a pasta do projeto exista no servidor
            cd /home/deployer/digicoin_project || mkdir -p /home/deployer/digicoin_project && cd /home/deployer/digicoin_project

            # Cria o arquivo mysql.txt no servidor
            cat << EOF > mysql.txt
            CREATE DATABASE IF NOT EXISTS \`${{ secrets.DB_NAME }}\`;
            USE \`${{ secrets.DB_NAME }}\`;
            SET GLOBAL event_scheduler = ON;

            DELIMITER $$

            CREATE PROCEDURE desativar_itens_expirados()
            BEGIN
                -- 1. Desativa DESAFIOS cuja dataFim já passou e que ainda estão ativos.
                UPDATE api_desafio
                SET is_active = FALSE
                WHERE dataFim < CURDATE() AND is_active = TRUE;

                -- 2. Desativa PRODUTOS e DESAFIOS relacionados a campanhas expiradas.
                UPDATE api_produto
                SET is_active = FALSE
                WHERE idCampanha_id IN (
                    SELECT id FROM api_campanha
                    WHERE dataFim < CURDATE() AND is_active = TRUE
                );

                UPDATE api_desafio
                SET is_active = FALSE
                WHERE idCampanha_id IN (
                    SELECT id FROM api_campanha
                    WHERE dataFim < CURDATE() AND is_active = TRUE
                );

                -- 3. Desativa as próprias CAMPANHAS expiradas.
                UPDATE api_campanha
                SET is_active = FALSE
                WHERE dataFim < CURDATE() AND is_active = TRUE;
            END$$

            DELIMITER ;

            CREATE EVENT desativar_campanhas_event
            ON SCHEDULE EVERY 1 DAY
            STARTS NOW()
            DO
                CALL desativar_itens_expirados();
            EOF

            # Cria o docker-compose.yml com o caminho para o mysql.txt ajustado
            cat << EOF > docker-compose.yml
            services:
              db:
                image: mysql:8.0
                command: --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci
                container_name: digicoin_mysql
                restart: unless-stopped
                environment:
                  MYSQL_ROOT_PASSWORD: \${DB_PASSWORD}
                  MYSQL_DATABASE: \${DB_NAME}
                  MYSQL_USER: \${DB_USER}
                  MYSQL_PASSWORD: \${DB_PASSWORD}
                volumes:
                  - mysql_data:/var/lib/mysql
                  - ./mysql.txt:/docker-entrypoint-initdb.d/init.sql
                networks:
                  - digicoin-net
              web:
                image: ${{ secrets.DOCKERHUB_USERNAME }}/digicoin_teste:latest
                container_name: digicoin_web
                restart: unless-stopped
                volumes:
                  - ../data/staticfiles:/app/staticfiles
                  - ../data/media:/app/media
                ports:
                  - "127.0.0.1:8000:8000"
                env_file: .env
                depends_on:
                  - db
                networks:
                  - digicoin-net
              adminer:
                image: adminer
                container_name: digicoin_adminer
                restart: unless-stopped
                ports:
                  - "127.0.0.1:8083:8080"
                networks:
                  - digicoin-net
            volumes:
              mysql_data:
            networks:
              digicoin-net:
            EOF
            
            # --- Cria a configuração do Nginx (PARA PROJETO DJANGO) ---
            cat << EOF > nginx.conf
            server {
                 # MODIFICADO: server_name agora lista todos os hosts do Django
                 server_name ${{ secrets.DJANGO_ALLOWED_HOSTS }};

                 location / {
                    # MODIFICADO: proxy_pass para a porta 8000 (Django)
                    proxy_pass http://127.0.0.1:8000; 
                    proxy_set_header Host \$host;
                    proxy_set_header X-Real-IP \$remote_addr;
                    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto \$scheme;
                 }
            }
            EOF
            
            # --- Bloco de Administração do Servidor ---
            # MODIFICADO: Usa DJANGO_PROJECT_DOMAIN (ou promptweb)
            NGINX_CONF_FILE="/etc/nginx/sites-available/${{ secrets.DJANGO_ALLOWED_HOSTS }}" 
            NGINX_LINK_FILE="/etc/nginx/sites-enabled/${{ secrets.DJANGO_ALLOWED_HOSTS }}"

            echo "Movendo configuração do Nginx..."
            # MODIFICADO: Usa DJANGO_PROJECT_DIR
            sudo /usr/bin/mv ${{ secrets.DJANGO_PROJECT_DIR }}/nginx.conf $NGINX_CONF_FILE
            
            echo "Ativando site no Nginx..."
            sudo /usr/bin/ln -sf $NGINX_CONF_FILE $NGINX_LINK_FILE
            
            echo "Testando configuração do Nginx..."
            sudo /usr/sbin/nginx -t
            if [ \$? -ne 0 ]; then
                echo "Erro na configuração do Nginx!"
                exit 1
            fi

            # Cria o arquivo .env no servidor
            echo "DJANGO_SECRET_KEY=${{ secrets.DJANGO_SECRET_KEY }}" > .env
            echo "DJANGO_ALLOWED_HOSTS=${{ secrets.SSH_HOST }},promptweb.com.br" >> .env
            echo "DB_NAME=${{ secrets.DB_NAME }}" >> .env
            echo "DB_USER=${{ secrets.DB_USER }}" >> .env
            echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}" >> .env
            echo "DB_HOST=db" >> .env
            echo "EMAIL_USER=${{ secrets.EMAIL_USER }}" >> .env
            echo "EMAIL_PASSWORD=${{ secrets.EMAIL_PASSWORD }}" >> .env
            echo "EMAIL_HOST=${{ secrets.EMAIL_HOST }}" >> .env
            echo "EMAIL_PORT=${{ secrets.EMAIL_PORT }}" >> .env
            
            # #Limpa o ambiente anterior, MAS PRESERVA OS VOLUMES (seu banco de dados)
            echo "Parando contêineres antigos..."
            docker compose down --remove-orphans

            # Limpa o ambiente anterior para garantir um início limpo
            #echo "Limpando ambiente anterior (contêineres e volumes)..."
            #docker compose down -v --remove-orphans
            
            # Baixa a versão mais recente da imagem da sua aplicação
            docker pull ${{ secrets.DOCKERHUB_USERNAME }}/digicoin_teste:latest
            
            # Sobe os serviços em background
            docker compose up -d

            # Espera inteligente para o banco de dados ficar pronto
            echo "Aguardando o banco de dados ficar pronto..."
            timeout=90
            while ! docker compose exec db mysqladmin ping -h"127.0.0.1" --silent; do
              sleep 3
              timeout=$(expr $timeout - 3)
              if [ $timeout -le 0 ]; then
                echo "Erro: Timeout esperando pelo banco de dados."
                docker compose logs db
                exit 1
              fi
            done
            echo "✅ Banco de dados está pronto!"
            
            # Executa os comandos de gerenciamento com as configurações de produção
            echo "Executando migrações..."
            docker compose exec -e DJANGO_SETTINGS_MODULE='Digicoin.settings.production' web python manage.py migrate --noinput
            
            echo "Criando admins..."
            docker compose exec -e DJANGO_SETTINGS_MODULE='Digicoin.settings.production' web python manage.py create_admins
            
            echo "Coletando arquivos estáticos..."
            docker compose exec -e DJANGO_SETTINGS_MODULE='Digicoin.settings.production' web python manage.py collectstatic --noinput --clear
            
            # imprime os logs de todos os serviços
            echo "Imprimindo logs..."
            echo "Logs web:"
            docker compose logs web
            echo "Logs adminer:"
            docker compose logs adminer
            echo "Logs db:"
            docker compose logs db

            echo "Iniciando o servidor..."            
            echo "✅ Deploy concluido com sucesso!"